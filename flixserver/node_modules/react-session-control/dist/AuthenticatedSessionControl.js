"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importStar(require("react"));
const SessionControlModal_1 = __importDefault(require("./SessionControlModal"));
const utils_1 = require("./utils");
require("../SessionControl.css");
const LAST_ACITIVTY_TIME_STORAGE_KEY = 'sc-last-activity-time';
const LOGOUT_CAUSE_STORAGE_KEY = 'sc-logout-cause';
var LogoutTypes;
(function (LogoutTypes) {
    LogoutTypes["button"] = "button";
    LogoutTypes["inactivity"] = "inactivity";
    LogoutTypes["lostToken"] = "lostToken";
})(LogoutTypes = exports.LogoutTypes || (exports.LogoutTypes = {}));
class AuthenticatedSessionControl extends react_1.PureComponent {
    constructor(props) {
        super(props);
        this._isMounted = true;
        this.originalDocumentTitle = null;
        this.inactivityTimeoutRef = null;
        this.modalTimerIntervalRef = null;
        const { modalInactivityTimeout, userActivityThrottleTime, tokenChangeDebounceTime } = props;
        this.state = {
            isModalOpen: false,
            modalTimer: modalInactivityTimeout,
        };
        this.handleVisibilityChange = this.handleVisibilityChange.bind(this);
        this.handleInactivityTimeout = this.handleInactivityTimeout.bind(this);
        this.handleModalTimer = this.handleModalTimer.bind(this);
        this.handleModalLogoutClick = this.handleModalLogoutClick.bind(this);
        this.handleModalContinueClick = this.handleModalContinueClick.bind(this);
        this.handleStorageChange = this.handleStorageChange.bind(this);
        this.handleStorageKeyChange = this.handleStorageKeyChange.bind(this);
        this.throttledHandleUserActivity = utils_1.throttle(this.handleUserActivity.bind(this, true), userActivityThrottleTime);
        this.debouncedHandleStorageKeyChange = utils_1.debounce(this.handleStorageKeyChange, tokenChangeDebounceTime);
        this.originalDocumentTitle = document.title;
    }
    componentDidMount() {
        this.debug('MOUNTED');
        this.load();
    }
    componentDidUpdate(prevProps) {
        if (prevProps.disabled !== this.props.disabled) {
            this.load();
        }
    }
    componentWillUnmount() {
        this._isMounted = false;
        this.removeActivityListeners();
        this.clearRefs();
        this.debug('UNMOUNTED');
    }
    load() {
        const { disabled } = this.props;
        if (disabled) {
            this.removeActivityListeners();
            this.clearRefs();
            this.setState({ isModalOpen: false });
        }
        else {
            this.initAcitivityListeners();
            this.handleUserActivity(true);
        }
        //Cleaning the last logout cause registered.
        localStorage.removeItem(LOGOUT_CAUSE_STORAGE_KEY);
    }
    debug(description) {
        const { debug } = this.props;
        if (debug) {
            console.log('REACT-SESSON-CONTROL-DEBUG: ', description);
        }
    }
    initAcitivityListeners() {
        document.addEventListener('visibilitychange', this.handleVisibilityChange);
        document.addEventListener('mousemove', this.throttledHandleUserActivity);
        document.addEventListener('keypress', this.throttledHandleUserActivity);
        window.addEventListener('storage', this.handleStorageChange);
    }
    removeActivityListeners() {
        document.removeEventListener('visibilitychange', this.handleVisibilityChange);
        document.removeEventListener('mousemove', this.throttledHandleUserActivity);
        document.removeEventListener('keypress', this.throttledHandleUserActivity);
        window.removeEventListener('storage', this.handleStorageChange);
    }
    clearRefs() {
        clearInterval(this.inactivityTimeoutRef);
        clearInterval(this.modalTimerIntervalRef);
    }
    resetDocumentTitle() {
        const { showDocumentTitleAlert } = this.props;
        if (showDocumentTitleAlert) {
            document.title = this.originalDocumentTitle;
        }
    }
    logout(logoutType, isFromOtherTab = false) {
        if (!this._isMounted) {
            return;
        }
        this.removeActivityListeners();
        this.clearRefs();
        this.debug(`LOGOUT TYPE: (${logoutType.toUpperCase()}) LOCAL: (${String(!isFromOtherTab)})`);
        if (!isFromOtherTab) {
            localStorage.setItem(LOGOUT_CAUSE_STORAGE_KEY, logoutType);
        }
        localStorage.removeItem(LAST_ACITIVTY_TIME_STORAGE_KEY);
        this.resetDocumentTitle();
        const { onLogout } = this.props;
        this.setState({ isModalOpen: false }, () => {
            if (onLogout) {
                onLogout(logoutType, !isFromOtherTab);
            }
        });
    }
    getProgressWidth() {
        const { modalInactivityTimeout } = this.props;
        const { modalTimer } = this.state;
        return `${modalTimer / modalInactivityTimeout * 100}%`;
    }
    verifyLastActivityTime() {
        const lastActivity = localStorage.getItem(LAST_ACITIVTY_TIME_STORAGE_KEY);
        if (lastActivity === null) {
            return true;
        }
        const { inactivityTimeout, modalInactivityTimeout } = this.props;
        const maximumDowntime = (inactivityTimeout + modalInactivityTimeout) * 1000;
        const inactivityTime = (Date.now() - Number(lastActivity));
        this.debug(`INACTIVITY TIME: (${inactivityTime}) DOWNTIME: (${maximumDowntime})`);
        return inactivityTime <= maximumDowntime;
    }
    handleVisibilityChange() {
        if (document.visibilityState === 'visible') {
            this.throttledHandleUserActivity(true);
        }
    }
    handleUserActivity(updateLastActivity = false) {
        const { isModalOpen } = this.state;
        const { inactivityTimeout, modalInactivityTimeout } = this.props;
        if (!this.verifyLastActivityTime()) {
            this.logout(LogoutTypes.inactivity);
            return;
        }
        if (updateLastActivity) {
            localStorage.setItem(LAST_ACITIVTY_TIME_STORAGE_KEY, Date.now().toString());
        }
        this.clearRefs();
        this.debug('ACTIVITY');
        if (isModalOpen) {
            this.resetDocumentTitle();
            this.setState({
                modalTimer: modalInactivityTimeout
            }, () => {
                this.modalTimerIntervalRef = setInterval(this.handleModalTimer, 1000);
            });
        }
        else {
            this.inactivityTimeoutRef = setTimeout(this.handleInactivityTimeout, inactivityTimeout * 1000);
        }
    }
    handleInactivityTimeout() {
        const { inactivityTimeout, onInactivityTimeout } = this.props;
        const lastActivity = localStorage.getItem(LAST_ACITIVTY_TIME_STORAGE_KEY);
        if (!lastActivity || Date.now() >= (Number(lastActivity) + (inactivityTimeout * 1000))) {
            if (onInactivityTimeout) {
                onInactivityTimeout();
            }
            this.setState({ isModalOpen: true }, () => {
                this.handleUserActivity();
            });
        }
        else {
            this.handleUserActivity();
        }
    }
    handleModalTimer() {
        const { showDocumentTitleAlert, documentTitleAlertText, onInactivityModalTimeout } = this.props;
        const { modalTimer } = this.state;
        if (modalTimer === 0) {
            if (onInactivityModalTimeout) {
                onInactivityModalTimeout();
            }
            this.logout(LogoutTypes.inactivity);
        }
        else {
            if (showDocumentTitleAlert) {
                if (document.title === this.originalDocumentTitle) {
                    document.title = documentTitleAlertText;
                }
                else {
                    document.title = this.originalDocumentTitle;
                }
            }
            this.setState({ modalTimer: modalTimer - 1 });
        }
    }
    handleStorageChange(event) {
        const { storageTokenKey } = this.props;
        //Checking if the token has been removed.
        if (storageTokenKey && event.key === storageTokenKey || event.key === null) {
            //Using debounce here to handle multiple changes.
            this.debouncedHandleStorageKeyChange(event);
        }
        //Checking if other tab register activity.
        if (event.key === LAST_ACITIVTY_TIME_STORAGE_KEY) {
            this.debug('OTHER TAB ACTIVITY -> CALLING LOCAL ACTIVITY');
            this.setState({ isModalOpen: false }, () => this.handleUserActivity());
        }
    }
    handleStorageKeyChange(event) {
        const { storageTokenKey } = this.props;
        const { newValue } = event;
        const currentTokenValue = localStorage.getItem(storageTokenKey);
        if (newValue == null && currentTokenValue == null) {
            this.debug(`LOST TOKEN - CURRENT VALUE: ${currentTokenValue}`);
            //Verifying if other table register logout cause.
            const logoutType = (localStorage.getItem(LOGOUT_CAUSE_STORAGE_KEY) || LogoutTypes.lostToken);
            this.logout(logoutType, true);
        }
    }
    handleModalLogoutClick() {
        this.logout(LogoutTypes.button);
    }
    handleModalContinueClick() {
        clearInterval(this.modalTimerIntervalRef);
        this.resetDocumentTitle();
        this.setState({ isModalOpen: false }, () => {
            this.handleUserActivity();
        });
    }
    render() {
        const { title, message, timerMessage, logoutButtonText, continueButtonText, renderModal: Modal } = this.props;
        const { modalTimer, isModalOpen } = this.state;
        const ModalComponent = Modal || SessionControlModal_1.default;
        return (react_1.default.createElement(ModalComponent, { isOpen: isModalOpen, title: title, message: message, timerMessage: timerMessage, logoutButtonText: logoutButtonText, continueButtonText: continueButtonText, remainingTime: modalTimer, progressPercent: this.getProgressWidth(), onContinueClick: this.handleModalContinueClick, onLogoutClick: this.handleModalLogoutClick }));
    }
}
exports.default = AuthenticatedSessionControl;
AuthenticatedSessionControl.defaultProps = {
    showDocumentTitleAlert: true,
    title: 'Inactivity alert',
    message: 'You have been inactive for a long time. Do you want to remain logged in?',
    continueButtonText: 'Continue',
    logoutButtonText: 'Logout',
    timerMessage: 'You will be disconnected in: ',
    documentTitleAlertText: 'INACTIVITY ALERT',
    tokenChangeDebounceTime: 500,
    userActivityThrottleTime: 500,
    disabled: false,
    debug: false
};
